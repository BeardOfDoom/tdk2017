package generator;

import static utils.VariableUtils.getVariableStruct;
import static utils.VariableUtils.getVariableType;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import representations.state.AttributeRepresentation;
import representations.state.StateRepresentation;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import javax.lang.model.element.Modifier;
import utils.VariableUtils;

public class StateGenerator {

  private static Map<String, List<String>> variableInitStatements = new HashMap<>();

  public static void generateStateDescription(String packageName, String directory,
      boolean keepTogetherGettersAndSetters) throws IOException {
    TypeSpec State = TypeSpec.classBuilder("State")
        .addModifiers(Modifier.PUBLIC)
        .addFields(getFields())
        .addMethods(getGettersAndSetters(keepTogetherGettersAndSetters))
        .build();

    JavaFile javaFile = JavaFile.builder(packageName, State)
        .skipJavaLangImports(true)
        .build();

    Path path = Paths.get(directory);

    javaFile.writeTo(path);
  }


  public static void generateState(StateRepresentation state, String directory,
      String packageName, String fileName, boolean keepTogetherGettersAndSetters) {

  }


  private static List<FieldSpec> getFields() {
    List<FieldSpec> fieldList = new ArrayList<>();

    for (AttributeRepresentation currentVariable : VariableUtils.getVariableList()) {
      String attributeName = currentVariable.getVariableName();
      Class structClass = currentVariable.getVarStruct();
      Class typeClass = currentVariable.getVarType();

      FieldSpec currentField = FieldSpec
          .builder(ParameterizedTypeName.get(structClass, typeClass), attributeName)
          .addModifiers(Modifier.PRIVATE)
          .initializer("new $T<>()", HashSet.class)
          .build();

      fieldList.add(currentField);
    }

    return fieldList;
  }

  private static MethodSpec getGetter(String attributeName) {
    Class structClass = getVariableStruct(attributeName);
    Class typeClass = getVariableType(attributeName);
    String upperCaseVariableName = getUpperCaseVariableName(attributeName);

    MethodSpec getterMethod = MethodSpec.methodBuilder("get" + upperCaseVariableName)
        .addModifiers(Modifier.PUBLIC)
        .returns(ParameterizedTypeName.get(structClass, typeClass))
        .build();

    return getterMethod;
  }

  private static MethodSpec getSetter(String attributeName) {
    Class structClass = getVariableStruct(attributeName);
    Class typeClass = getVariableType(attributeName);
    String upperCaseVariableName = getUpperCaseVariableName(attributeName);

    MethodSpec setterMethod = MethodSpec.methodBuilder("set" + upperCaseVariableName)
        .addModifiers(Modifier.PUBLIC)
        .returns(TypeName.VOID)
        .addParameter(ParameterizedTypeName.get(structClass, typeClass), attributeName)
        .addStatement("this." + attributeName + " = " + attributeName)
        .build();

    return setterMethod;
  }

  private static List<MethodSpec> getGettersAndSetters(boolean keepTogetherGettersAndSetters) {
    List<MethodSpec> gettersAndSetters = new ArrayList<>();
    if (keepTogetherGettersAndSetters) {
      for (String currentVariable : VariableUtils.getVariableNames()) {
        gettersAndSetters.add(getGetter(currentVariable));
        gettersAndSetters.add(getSetter(currentVariable));
      }
    } else {
      for (String currentVariable : VariableUtils.getVariableNames()) {
        gettersAndSetters.add(getGetter(currentVariable));
      }
      for (String currentVariable : VariableUtils.getVariableNames()) {
        gettersAndSetters.add(getSetter(currentVariable));
      }
    }
    return gettersAndSetters;
  }

  private static String getUpperCaseVariableName(String attributeName) {
    return Character.toUpperCase(attributeName.charAt(0)) + attributeName.substring(1);
  }
}
